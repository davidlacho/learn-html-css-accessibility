<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learn HTML, CSS & Accessible Web Design</title>
    <link rel="stylesheet" href="styles.css">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Translation system - load all content from external JSON file
        let translations = {};
        let translationsLoaded = false;

        // Load translations.json
        fetch('translations.json')
            .then(response => response.json())
            .then(data => {
                translations = data;
                translationsLoaded = true;
                // Force update any components waiting for translations
                if (window.forceUpdate) {
                    window.forceUpdate();
                }
            })
            .catch(error => {
                console.error('Error loading translations:', error);
                // Fallback: translations will be empty, app will use keys
                translationsLoaded = true;
            });

        // Translation helper function
        function t(key, params = {}) {
            if (!translationsLoaded) return key;
            const lang = window.currentLanguage || 'en';
            const keys = key.split('.');
            let value = translations[lang];
            
            for (const k of keys) {
                if (value && typeof value === 'object' && k in value) {
                    value = value[k];
                } else {
                    // Fallback to English if translation not found
                    value = translations.en;
                    for (const k2 of keys) {
                        if (value && typeof value === 'object' && k2 in value) {
                            value = value[k2];
                        } else {
                            return key;
                        }
                    }
                    break;
                }
            }
            
            if (typeof value !== 'string') return key;
            
            // Replace parameters
            return value.replace(/\{(\w+)\}/g, (match, param) => {
                return params[param] !== undefined ? params[param] : match;
            });
        }

        // Get translated glossary definition
        function getTranslatedGlossary(term) {
            if (!translationsLoaded) return glossary[term] || glossary[term.toLowerCase()];
            const lang = window.currentLanguage || 'en';
            
            // Try to get from translated glossary
            const translatedGlossary = translations[lang]?.glossary;
            if (translatedGlossary && typeof translatedGlossary === 'object') {
                if (term in translatedGlossary) {
                    return translatedGlossary[term];
                }
                if (term.toLowerCase() in translatedGlossary) {
                    return translatedGlossary[term.toLowerCase()];
                }
            }
            
            // Fallback to English glossary in translations
            const enGlossary = translations.en?.glossary;
            if (enGlossary && typeof enGlossary === 'object') {
                if (term in enGlossary) {
                    return enGlossary[term];
                }
                if (term.toLowerCase() in enGlossary) {
                    return enGlossary[term.toLowerCase()];
                }
            }
            
            // Final fallback to original glossary object
            return glossary[term] || glossary[term.toLowerCase()];
        }

        // Get translated lesson data
        function getTranslatedLesson(lesson, langOverride = null) {
            if (!translationsLoaded) return lesson;
            const lang = langOverride || window.currentLanguage || 'en';
            const lessonTranslations = translations[lang]?.lessons?.[lesson.id];
            
            // Map category names to translation keys
            const categoryMap = {
                'HTML Fundamentals': 'htmlFundamentals',
                'HTML': 'html',
                'CSS': 'css',
                'Accessibility': 'accessibility'
            };
            const categoryKey = categoryMap[lesson.category] || lesson.category.toLowerCase().replace(/\s+/g, '');
            const translatedCategory = t(`categories.${categoryKey}`) || lesson.category;
            
            if (!lessonTranslations) {
                // Fallback to English or original lesson
                const enTranslations = translations.en?.lessons?.[lesson.id];
                if (enTranslations) {
                    return {
                        ...lesson,
                        category: translatedCategory,
                        title: enTranslations.title || lesson.title,
                        description: enTranslations.description || lesson.description,
                        whyImportant: enTranslations.whyImportant || lesson.whyImportant,
                        whatToDo: enTranslations.whatToDo || lesson.whatToDo,
                        w3schoolsLinks: enTranslations.w3schoolsLinks || lesson.w3schoolsLinks,
                        expectedElements: enTranslations.expectedElements || lesson.expectedElements,
                        codeTemplate: enTranslations.codeTemplate || lesson.codeTemplate
                    };
                }
                // If no translations at all, use original with translated category
                return {
                    ...lesson,
                    category: translatedCategory
                };
            }
            
            return {
                ...lesson,
                category: translatedCategory,
                title: lessonTranslations.title || lesson.title,
                description: lessonTranslations.description || lesson.description,
                whyImportant: lessonTranslations.whyImportant || lesson.whyImportant,
                whatToDo: lessonTranslations.whatToDo || lesson.whatToDo,
                w3schoolsLinks: lessonTranslations.w3schoolsLinks || lesson.w3schoolsLinks,
                expectedElements: lessonTranslations.expectedElements || lesson.expectedElements,
                codeTemplate: lessonTranslations.codeTemplate || lesson.codeTemplate
            };
        }

        // Lesson data structure
        const lessons = [
            {
                id: 'fundamentals-1',
                category: 'HTML Fundamentals',
                validator: (code) => {
                    const hasOpeningTag = /<[a-z]+[^>]*>/i.test(code);
                    const hasClosingTag = /<\/[a-z]+>/i.test(code);
                    return hasOpeningTag && hasClosingTag;
                }
            },
            {
                id: 'fundamentals-2',
                category: 'HTML Fundamentals',
                validator: (code) => {
                    const hasP = /<p[^>]*>.*<\/p>/i.test(code);
                    const hasContent = /<p[^>]*>[^<]+<\/p>/i.test(code);
                    return hasP && hasContent;
                }
            },
            {
                id: 'fundamentals-3',
                category: 'HTML Fundamentals',
                validator: (code) => {
                    const hasId = /<[a-z]+[^>]*\s+id\s*=\s*["'][^"']+["'][^>]*>/i.test(code);
                    const hasClass = /<[a-z]+[^>]*\s+class\s*=\s*["'][^"']+["'][^>]*>/i.test(code);
                    return hasId && hasClass;
                }
            },
            {
                id: 'fundamentals-4',
                category: 'HTML Fundamentals',
                validator: (code) => {
                    const hasDiv = /<div[^>]*>.*<\/div>/i.test(code);
                    const hasDivWithClass = /<div[^>]*class\s*=\s*["'][^"']+["'][^>]*>.*<\/div>/i.test(code);
                    const hasSpan = /<span[^>]*>.*<\/span>/i.test(code);
                    const hasStrong = /<strong[^>]*>.*<\/strong>/i.test(code);
                    const hasEm = /<em[^>]*>.*<\/em>/i.test(code);
                    return hasDivWithClass && hasSpan && (hasStrong || hasEm);
                }
            },
            {
                id: 'html-1',
                category: 'HTML',
                validator: (code) => {
                    const hasHtml = /<html/i.test(code);
                    const hasHead = /<head/i.test(code);
                    const hasTitle = /<title/i.test(code);
                    const hasBody = /<body/i.test(code);
                    return hasHtml && hasHead && hasTitle && hasBody;
                }
            },
            {
                id: 'html-2',
                category: 'HTML',
                validator: (code) => {
                    const hasH1 = /<h1[^>]*>.*<\/h1>/i.test(code);
                    const hasP = /<p[^>]*>.*<\/p>/i.test(code);
                    return hasH1 && hasP;
                }
            },
            {
                id: 'html-3',
                category: 'HTML',
                validator: (code) => {
                    const hasList = /<(ul|ol)[^>]*>.*<\/(ul|ol)>/i.test(code);
                    const hasLi = /<li[^>]*>.*<\/li>/i.test(code);
                    return hasList && hasLi;
                }
            },
            {
                id: 'html-4',
                category: 'HTML',
                validator: (code) => {
                    const hasLink = /<a[^>]*href\s*=\s*["'][^"']+["'][^>]*>.*<\/a>/i.test(code);
                    return hasLink;
                }
            },
            {
                id: 'html-5',
                category: 'HTML',
                validator: (code) => {
                    const hasImg = /<img[^>]*src\s*=\s*["'][^"']+["'][^>]*>/i.test(code);
                    const hasAlt = /<img[^>]*alt\s*=\s*["'][^"']+["'][^>]*>/i.test(code);
                    return hasImg && hasAlt;
                }
            },
            {
                id: 'css-1',
                category: 'CSS',
                validator: (code) => {
                    const hasStyle = /<style[^>]*>/i.test(code);
                    const hasCssRule = /[a-z-]+\s*:\s*[^;]+;/i.test(code);
                    return hasStyle && hasCssRule;
                }
            },
            {
                id: 'css-2',
                category: 'CSS',
                validator: (code) => {
                    const hasStyle = /<style[^>]*>/i.test(code);
                    const hasTextStyling = /(color|font-size|font-weight)\s*:\s*[^;]+;/i.test(code);
                    return hasStyle && hasTextStyling;
                }
            },
            {
                id: 'css-3',
                category: 'CSS',
                validator: (code) => {
                    const hasStyle = /<style[^>]*>/i.test(code);
                    const hasBgOrBorder = /(background-color|border)\s*:\s*[^;]+;/i.test(code);
                    return hasStyle && hasBgOrBorder;
                }
            },
            {
                id: 'css-4',
                category: 'CSS',
                validator: (code) => {
                    const hasStyle = /<style[^>]*>/i.test(code);
                    const hasSpacing = /(margin|padding)\s*:\s*[^;]+;/i.test(code);
                    return hasStyle && hasSpacing;
                }
            },
            {
                id: 'css-5',
                category: 'CSS',
                validator: (code) => {
                    const hasStyle = /<style[^>]*>/i.test(code);
                    const hasIdOrClass = /(#[a-z-]+|\.[a-z-]+)\s*\{/i.test(code);
                    return hasStyle && hasIdOrClass;
                }
            },
            {
                id: 'accessibility-1',
                category: 'Accessibility',
                validator: (code) => {
                    const hasLang = /<html[^>]*lang\s*=\s*["'][^"']+["'][^>]*>/i.test(code);
                    const hasSemantic = /<(header|main|footer|nav|article|section)[^>]*>/i.test(code);
                    return hasLang && hasSemantic;
                }
            },
            {
                id: 'accessibility-2',
                category: 'Accessibility',
                validator: (code) => {
                    const hasImg = /<img[^>]*>/i.test(code);
                    const hasAlt = /<img[^>]*alt\s*=\s*["'][^"']+["'][^>]*>/i.test(code);
                    return hasImg && hasAlt && code.match(/alt\s*=\s*["'][^"']{10,}["']/i);
                }
            },
            {
                id: 'accessibility-3',
                category: 'Accessibility',
                validator: (code) => {
                    const hasH1 = /<h1[^>]*>/i.test(code);
                    const hasH2 = /<h2[^>]*>/i.test(code);
                    const h1Index = code.search(/<h1[^>]*>/i);
                    const h2Index = code.search(/<h2[^>]*>/i);
                    return hasH1 && hasH2 && h1Index < h2Index;
                }
            },
            {
                id: 'accessibility-4',
                category: 'Accessibility',
                validator: (code) => {
                    const hasNav = /<nav[^>]*>/i.test(code);
                    const hasLinks = /<a[^>]*href[^>]*>/i.test(code);
                    const hasFocusStyle = /:focus\s*\{[^}]*\}/i.test(code);
                    return hasNav && hasLinks && hasFocusStyle;
                }
            },
            {
                id: 'accessibility-5',
                category: 'Accessibility',
                validator: (code) => {
                    const hasInput = /<input[^>]*>/i.test(code);
                    const hasLabel = /<label[^>]*for\s*=\s*["'][^"']+["'][^>]*>.*<\/label>/i.test(code);
                    const hasAriaLabel = /aria-label\s*=\s*["'][^"']+["']/i.test(code);
                    return hasInput && (hasLabel || hasAriaLabel);
                }
            },
            {
                id: 'accessibility-6',
                category: 'Accessibility',
                validator: (code) => {
                    const hasAriaDescribedby = /aria-describedby\s*=\s*["'][^"']+["']/i.test(code);
                    const hasAriaExpanded = /aria-expanded\s*=\s*["'](true|false)["']/i.test(code);
                    const hasRole = /role\s*=\s*["'][^"']+["']/i.test(code);
                    return (hasAriaDescribedby || hasAriaExpanded) && hasRole;
                }
            }
        ];


        // Glossary of key terms with definitions
        const glossary = {
            // HTML Terms
            'HTML': 'HyperText Markup Language - the standard language for creating webpages. It structures content using tags.',
            'tags': 'HTML tags are elements that mark up content. They come in pairs: opening tag <tag> and closing tag </tag>.',
            'element': 'An HTML element consists of an opening tag, content, and closing tag. Examples: <p>text</p> is a paragraph element.',
            '<html>': 'The root element that wraps all HTML content on a webpage.',
            '<head>': 'Contains metadata about the document, like title and styles, not visible on the page.',
            '<body>': 'Contains all visible content that appears on the webpage.',
            '<title>': 'Sets the text shown in the browser tab or window title.',
            '<h1>': 'The main heading (largest). Use only one per page for the main title.',
            '<h2>': 'A section heading, smaller than h1. Use for major sections.',
            '<h3>': 'A subsection heading, smaller than h2. Use for subsections.',
            '<h4>': 'A smaller heading, used for sub-subsections.',
            '<h5>': 'An even smaller heading level.',
            '<h6>': 'The smallest heading level.',
            'heading': 'Headings (h1-h6) create a hierarchy to organize content. Screen readers use them for navigation.',
            '<p>': 'Paragraph tag for blocks of text content.',
            '<a>': 'Anchor tag creates clickable links to other pages or websites.',
            '<img>': 'Image tag displays pictures. Requires src (image location) and alt (description) attributes.',
            '<ul>': 'Unordered list creates a bulleted list of items.',
            '<ol>': 'Ordered list creates a numbered list of items.',
            '<li>': 'List item tag used inside <ul> or <ol> for each list entry.',
            '<header>': 'Semantic tag for the top section of a page, typically containing logo and navigation.',
            '<nav>': 'Semantic tag for navigation links.',
            '<main>': 'Semantic tag for the main content of the page (only one per page).',
            '<article>': 'Semantic tag for standalone content like blog posts or news articles.',
            '<footer>': 'Semantic tag for the bottom section, often containing copyright and links.',
            '<div>': 'Generic container element that groups content together. Has no visual meaning by itself but helps organize and style content. Use semantic tags like <header> or <main> when possible.',
            '<span>': 'Inline container element used to group inline content for styling. Similar to <div> but for inline elements.',
            '<strong>': 'Tag that makes text bold and indicates importance. Screen readers emphasize it.',
            '<em>': 'Tag that makes text italic and indicates emphasis. Screen readers stress it.',
            'opening tag': 'The first tag that starts an element, like <p>.',
            'closing tag': 'The tag that ends an element, with a forward slash, like </p>.',
            'angle brackets': 'The < and > symbols used to enclose HTML tags, like <p> and </p>.',
            'forward slash': 'The / symbol used in closing tags, like </p> or self-closing tags like <img />.',
            'attributes': 'Extra information added to opening tags, like href="url" or alt="description".',
            'href': 'Attribute used in <a> tags to specify the link destination URL.',
            'src': 'Attribute used in <img> tags to specify the image file location.',
            'alt': 'Attribute in <img> tags providing text description for screen readers and when images fail to load.',
            'id': 'HTML attribute that gives an element a unique identifier. Only one element per page can have a specific ID. Used with # in CSS.',
            'class': 'HTML attribute that groups elements together. Multiple elements can share the same class. Used with . in CSS for styling.',
            'parent element': 'An HTML element that contains other elements (children). For example, <div> is a parent if it contains <p> tags inside it.',
            'child element': 'An HTML element that is inside another element (its parent). For example, <p> is a child if it\'s inside a <div> tag.',
            'hierarchy': 'The structure of parent-child relationships in HTML. Elements can contain other elements, creating a tree-like structure.',
            'inline': 'Elements that flow with text and don\'t create line breaks, like <span> or <a>. Opposite of block elements.',
            'block': 'Elements that create a new line and take full width, like <div> or <p>. Opposite of inline elements.',
            'JavaScript': 'A programming language that makes webpages interactive. Can be used with HTML and CSS to add dynamic behavior.',
            'ordered list': 'A list with numbers (1, 2, 3...), created with <ol> tag. Each item uses <li> tag.',
            'unordered list': 'A list with bullets, created with <ul> tag. Each item uses <li> tag.',
            'list item': 'An individual item in a list, created with <li> tag. Used inside <ul> or <ol> tags.',
            'anchor': 'Another name for the <a> tag, which creates clickable links. The "a" stands for anchor.',
            'form': 'An HTML element (<form>) that collects user input, like text fields, checkboxes, or submit buttons.',
            'input': 'An HTML element (<input>) used inside forms to collect different types of user data, like text, email, or passwords.',
            'display': 'CSS property that controls how an element is displayed, like block, inline, or flex. Determines layout behavior.',
            'container': 'An element that groups or wraps other elements together, like <div> or <section>. Used for organization and styling.',
            'reusable': 'Code or styles that can be used multiple times. Classes are reusable - many elements can share the same class.',
            'unique': 'Something that appears only once. IDs are unique - only one element per page can have a specific ID.',
            'identifier': 'A name that identifies something. In HTML, id and class are identifiers that help you target specific elements.',
            'semantic HTML': 'Using meaningful tags like <header> and <main> instead of generic <div> tags. Helps screen readers and search engines understand page structure.',
            'content': 'The text, images, or other material inside HTML tags that appears on the webpage.',
            'webpage': 'A single page on the World Wide Web, created with HTML and displayed in a browser.',
            'browser': 'Software that displays webpages, like Chrome, Firefox, Safari, or Edge. It reads HTML and CSS to show the page.',
            'browser tab': 'A tab in the browser window that displays a webpage. Each tab shows the page title in the tab label.',
            'metadata': 'Information about a webpage that isn\'t visible on the page itself, like the title, description, or styles. Goes in the <head> section.',
            'search engines': 'Services like Google that index webpages. They use semantic HTML to understand page content and structure.',
            'navigation': 'Links and menus that help users move around a website. Usually created with <nav> and <a> tags.',
            'URL': 'Uniform Resource Locator - the web address that identifies a webpage, like https://example.com.',
            'web': 'Short for World Wide Web - the system of interconnected webpages accessible via the internet.',
            'interactive elements': 'HTML elements that users can interact with, like links (<a>), buttons, and form inputs. Must be keyboard accessible.',
            'buttons': 'Clickable elements that perform actions. Can be created with <button> tag or styled <a> tags.',
            
            // CSS Terms
            'CSS': 'Cascading Style Sheets - the language that styles HTML, controlling colors, fonts, spacing, and layout.',
            'styling': 'The process of making HTML look good using CSS - adding colors, fonts, spacing, and visual design.',
            '<style>': 'HTML tag that contains CSS code for styling the page.',
            'color': 'CSS property that sets the text color, like color: blue;',
            'font-size': 'CSS property that sets the size of text, like font-size: 16px;',
            'font-weight': 'CSS property that sets how bold text appears, like font-weight: bold; or font-weight: 400;',
            'background-color': 'CSS property that sets the background color of an element.',
            'border': 'CSS property that adds a border around an element, like border: 2px solid black;',
            'margin': 'CSS property that creates space outside an element (between elements).',
            'padding': 'CSS property that creates space inside an element (between content and border).',
            'spacing': 'The gaps and distances between elements, controlled by margin and padding in CSS.',
            ':focus': 'CSS pseudo-class that styles elements when they have keyboard focus (when user tabs to them).',
            'pseudo-class': 'A CSS feature that styles elements in special states, like :focus (when focused) or :hover (when mouse is over).',
            'selector': 'The part of a CSS rule that targets which HTML elements to style, like h1 or p.',
            'ID selector': 'CSS selector using # to target an element by its id attribute, like #myDiv { }. IDs are unique.',
            'class selector': 'CSS selector using . to target elements by their class attribute, like .highlight { }. Classes can be reused.',
            'property': 'The CSS feature being changed, like color or font-size.',
            'value': 'The setting for a CSS property, like blue or 16px.',
            'CSS rule': 'A complete CSS statement: selector { property: value; }',
            'outline': 'CSS property that creates a line around an element, often used for focus indicators. Similar to border but doesn\'t take up space.',
            'px': 'Pixels - a unit of measurement in CSS. 1px is one pixel on the screen. Used for sizes like font-size: 16px;',
            'semicolon': 'The ; symbol that ends each CSS property declaration. Required after every CSS property value.',
            'layout': 'How elements are arranged and positioned on a webpage, controlled by CSS.',
            'presentation': 'The visual appearance of a webpage - colors, fonts, spacing - controlled by CSS, separate from HTML content.',
            'readability': 'How easy text is to read, improved by good font choices, spacing, colors, and contrast.',
            'visual hierarchy': 'Using size, color, spacing, and styling to show which content is most important and guide the user\'s eye.',
            'design': 'The overall look and feel of a webpage, created through CSS styling choices.',
            'maintainable': 'Code that is easy to update and modify. Separating HTML (content) from CSS (styling) makes code more maintainable.',
            'box-sizing': 'CSS property that controls how element width and height are calculated. border-box includes padding and border in the total size.',
            'flex': 'CSS display value that creates flexible layouts. Elements can grow, shrink, and align in a container. Used with flexbox properties.',
            'flexbox': 'A CSS layout method using display: flex. Allows flexible arrangement of elements in rows or columns with easy alignment.',
            'flex-direction': 'CSS property that sets the direction of flex items: row (horizontal) or column (vertical).',
            'flex-wrap': 'CSS property that controls whether flex items wrap to a new line when they don\'t fit.',
            'vh': 'Viewport height unit - 1vh equals 1% of the browser window height. 100vh is the full screen height.',
            'vw': 'Viewport width unit - 1vw equals 1% of the browser window width. 100vw is the full screen width.',
            'transition': 'CSS property that creates smooth animations when properties change, like transition: background 0.3s;',
            'opacity': 'CSS property that controls element transparency. Values from 0 (invisible) to 1 (fully visible).',
            'border-radius': 'CSS property that rounds the corners of elements, like border-radius: 5px; for slightly rounded corners.',
            'line-height': 'CSS property that sets the spacing between lines of text, improving readability. Often set to 1.5 or 1.6.',
            'font-family': 'CSS property that sets the font typeface, like font-family: Arial, sans-serif;',
            'viewport': 'The visible area of a webpage in the browser window. The viewport meta tag controls how pages display on mobile devices.',
            'overflow': 'CSS property that controls what happens when content is too large for its container: visible, hidden, scroll, or auto.',
            'z-index': 'CSS property that controls the stacking order of elements. Higher values appear on top. Only works with positioned elements.',
            'position': 'CSS property that sets how an element is positioned: static, relative, absolute, fixed, or sticky.',
            'solid': 'A border style in CSS that creates a solid line, like border: 2px solid black;',
            'hover': 'CSS pseudo-class :hover that styles elements when the mouse pointer is over them.',
            'monospace': 'A font type where all characters have the same width, commonly used for code. Examples: Courier, Consolas.',
            'sans-serif': 'A font type without decorative strokes at the ends of letters. Examples: Arial, Helvetica, Verdana. Often used for body text.',
            'serif': 'A font type with decorative strokes at the ends of letters. Examples: Times New Roman, Georgia. Often used for printed text.',
            
            // Accessibility Terms
            'screen readers': 'Software that reads webpage content aloud for users with visual impairments. They rely on semantic HTML and proper structure.',
            'alt text': 'Text description of images for screen readers. Should describe what the image shows, not just say "image".',
            'heading hierarchy': 'The logical order of headings (h1 → h2 → h3). Never skip levels. Screen readers use this to navigate.',
            'keyboard navigation': 'Using only keyboard (Tab, Enter, Arrow keys) to navigate a website, essential for users who cannot use a mouse.',
            'Tab': 'The Tab key on the keyboard, used to move focus between interactive elements on a webpage.',
            'focus': 'The highlighted state when an element is selected via keyboard navigation. Must be visible with :focus styles.',
            'focus styles': 'CSS styles applied with :focus pseudo-class to make keyboard-focused elements visible, like outline or background-color changes.',
            'accessible': 'Websites that work for everyone, including people with disabilities using assistive technologies.',
            'ARIA': 'Accessible Rich Internet Applications - attributes that help screen readers understand dynamic content.',
            'aria-label': 'ARIA attribute that provides an accessible name for an element when the visible label isn\'t sufficient. Essential for icon buttons and custom controls.',
            'role': 'ARIA attribute that describes what an element does, like role="button" or role="navigation". Helps screen readers understand element purpose.',
            'aria-describedby': 'ARIA attribute that connects an element to its description by referencing the ID of the description element.',
            'aria-expanded': 'ARIA attribute that indicates whether a collapsible element (like a dropdown or accordion) is expanded (true) or collapsed (false).',
            'aria-hidden': 'ARIA attribute that hides decorative elements from screen readers. Set to "true" for purely visual elements that don\'t add meaning.',
            'tabindex': 'HTML attribute that controls keyboard navigation order. tabindex="0" makes an element focusable. tabindex="-1" removes from tab order.',
            'lang': 'HTML attribute on <html> tag that specifies the page language, like lang="en" for English. Helps screen readers pronounce text correctly.',
            '<label>': 'HTML tag that provides a text label for form inputs. Improves accessibility and allows clicking the label to focus the input.',
            'assistive technologies': 'Tools like screen readers, voice control, or keyboard-only navigation that help people with disabilities use websites.',
            'visual impairments': 'Conditions that affect a person\'s ability to see, requiring assistive technologies like screen readers to access web content.',
            'accessible web design': 'Designing websites so they work for all users, including those with disabilities, following accessibility principles and standards.'
        };

        // Copy glossary to translations.en.glossary
        if (translations.en && (!translations.en.glossary || Object.keys(translations.en.glossary).length === 0)) {
            translations.en.glossary = { ...glossary };
        }

        // Function to wrap terms with tooltips
        function addTooltips(text) {
            if (!text) return text;
            
            // Sort terms by length (longest first) to match longer phrases first
            const sortedTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);
            
            let result = text;
            const usedIndices = new Set();
            
            sortedTerms.forEach(term => {
                // Create regex to find the term, case-insensitive, but not inside HTML tags
                const regex = new RegExp(`\\b${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
                const matches = [...result.matchAll(regex)];
                
                // Process matches in reverse order to maintain indices
                matches.reverse().forEach(match => {
                    const startIndex = match.index;
                    const endIndex = startIndex + match[0].length;
                    
                    // Check if this position is already wrapped or inside HTML tags
                    let isInsideTag = false;
                    const beforeMatch = result.substring(0, startIndex);
                    const lastOpenTag = beforeMatch.lastIndexOf('<');
                    const lastCloseTag = beforeMatch.lastIndexOf('>');
                    if (lastOpenTag > lastCloseTag) {
                        isInsideTag = true;
                    }
                    
                    // Check if already wrapped
                    let alreadyWrapped = false;
                    for (let i = startIndex; i < endIndex; i++) {
                        if (usedIndices.has(i)) {
                            alreadyWrapped = true;
                            break;
                        }
                    }
                    
                    if (!isInsideTag && !alreadyWrapped) {
                        const termText = match[0];
                        const definition = glossary[term.toLowerCase()] || glossary[term];
                        if (definition) {
                            const tooltipId = `tooltip-${term.replace(/[^a-z0-9]/gi, '-')}-${startIndex}`;
                            const wrapped = (
                                <span key={tooltipId} className="tooltip-wrapper" tabIndex="0" role="button" aria-describedby={tooltipId}>
                                    {termText}
                                    <span id={tooltipId} className="tooltip" role="tooltip">
                                        {definition}
                                    </span>
                                </span>
                            );
                            
                            // Mark indices as used
                            for (let i = startIndex; i < endIndex; i++) {
                                usedIndices.add(i);
                            }
                            
                            // Replace in result (we'll handle this differently since we need React elements)
                            // For now, we'll use a placeholder and process later
                        }
                    }
                });
            });
            
            // Since we're working with strings, we'll create a function that returns React elements
            return result;
        }

        // Component to render text with tooltips
        function TextWithTooltips({ text }) {
            if (!text) return null;
            
            // Create a case-insensitive lookup map using translated glossary
            const glossaryMap = new Map();
            Object.keys(glossary).forEach(key => {
                const translatedDef = getTranslatedGlossary(key);
                glossaryMap.set(key.toLowerCase(), translatedDef);
            });
            
            const sortedTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);
            const parts = [];
            let remaining = text;
            let keyCounter = 0;
            
            while (remaining.length > 0) {
                let matched = false;
                
                for (const term of sortedTerms) {
                    // Escape special regex characters
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // For terms with angle brackets, don't use word boundaries
                    const useWordBoundary = !term.startsWith('<') && !term.includes('>');
                    const regex = useWordBoundary 
                        ? new RegExp(`\\b${escapedTerm}\\b`, 'i')
                        : new RegExp(escapedTerm, 'gi');
                    
                    const match = remaining.match(regex);
                    
                    if (match) {
                        const matchIndex = remaining.indexOf(match[0]);
                        const beforeMatch = remaining.substring(0, matchIndex);
                        const matchedTerm = match[0];
                        const afterMatch = remaining.substring(matchIndex + matchedTerm.length);
                        
                        // Check if inside HTML tag (but allow HTML tag names themselves)
                        const lastOpenTag = beforeMatch.lastIndexOf('<');
                        const lastCloseTag = beforeMatch.lastIndexOf('>');
                        const isInsideTag = lastOpenTag > lastCloseTag && !term.startsWith('<');
                        
                        if (!isInsideTag) {
                            const definition = glossaryMap.get(term.toLowerCase()) || getTranslatedGlossary(term);
                            if (definition) {
                                if (beforeMatch) {
                                    parts.push(<React.Fragment key={`text-${keyCounter++}`}>{beforeMatch}</React.Fragment>);
                                }
                                
                                const tooltipId = `tooltip-${keyCounter}`;
                                parts.push(
                                    <span key={tooltipId} className="tooltip-wrapper" tabIndex="0" role="button" aria-describedby={tooltipId}>
                                        {matchedTerm}
                                        <span id={tooltipId} className="tooltip" role="tooltip">
                                            {definition}
                                        </span>
                                    </span>
                                );
                                keyCounter++;
                                
                                remaining = afterMatch;
                                matched = true;
                                break;
                            }
                        }
                    }
                }
                
                if (!matched) {
                    // No match found, add remaining text
                    if (remaining.length > 0) {
                        parts.push(<React.Fragment key={`text-${keyCounter++}`}>{remaining}</React.Fragment>);
                    }
                    break;
                }
            }
            
            return <>{parts}</>;
        }

        // Simple hash encoding/decoding
        function encodeState(state) {
            try {
                const json = JSON.stringify(state);
                return btoa(encodeURIComponent(json));
            } catch (e) {
                return '';
            }
        }

        function decodeState(hash) {
            try {
                const json = decodeURIComponent(atob(hash));
                return JSON.parse(json);
            } catch (e) {
                return null;
            }
        }

        function App() {
            const [studentName, setStudentName] = useState('');
            const [currentLessonIndex, setCurrentLessonIndex] = useState(0);
            const [code, setCode] = useState('');
            const [feedback, setFeedback] = useState(null);
            const [hasStarted, setHasStarted] = useState(false);
            const [hintExpanded, setHintExpanded] = useState(false);
            const [completedLessons, setCompletedLessons] = useState(new Set());
            const [language, setLanguage] = useState('en');
            const [refreshKey, setRefreshKey] = useState(0);
            const previewFrameRef = useRef(null);
            const codeRef = useRef('');

            // Update global language and HTML lang attribute
            useEffect(() => {
                window.currentLanguage = language;
                document.documentElement.lang = language;
                setRefreshKey(prev => prev + 1); // Force re-render
            }, [language]);

            // Keep codeRef in sync with code state
            useEffect(() => {
                codeRef.current = code;
            }, [code]);

            // Update code template when language changes or translations load (if code matches any template)
            useEffect(() => {
                if (!hasStarted || currentLessonIndex >= lessons.length || !translationsLoaded) return;
                
                    const currentLessonRaw = lessons[currentLessonIndex];
                const originalTemplate = currentLessonRaw.codeTemplate || '';
                const translatedLesson = getTranslatedLesson(currentLessonRaw, language);
                const translatedTemplate = translatedLesson.codeTemplate || '';
                
                // Get the template for the current language
                const currentLangTemplate = translatedTemplate || originalTemplate;
                
                // Helper function to normalize code for comparison (normalizes whitespace)
                const normalizeCode = (code) => {
                    return code.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n')
                        .replace(/\n\s*\n/g, '\n')  // Remove blank lines
                        .replace(/[ \t]+/g, ' ')      // Normalize spaces/tabs
                        .replace(/\n /g, '\n')        // Remove leading spaces after newlines
                        .trim();
                };
                
                // If we have templates and they differ, check if we should update
                if (originalTemplate && translatedTemplate && originalTemplate !== translatedTemplate) {
                    const currentCode = codeRef.current;
                    const normalizedCurrent = normalizeCode(currentCode);
                    const normalizedOriginal = normalizeCode(originalTemplate);
                    const normalizedTranslated = normalizeCode(translatedTemplate);
                    
                    // Update if code matches either template (normalized) or is empty
                    if (normalizedCurrent === normalizedOriginal || 
                        normalizedCurrent === normalizedTranslated || 
                        currentCode.trim() === '') {
                        setCode(currentLangTemplate);
                    }
                } else if (currentLangTemplate && codeRef.current.trim() === '') {
                    // If no translation but code is empty, set the template
                    setCode(currentLangTemplate);
                }
            }, [language, currentLessonIndex, hasStarted, translationsLoaded]);

            // Set up forceUpdate function for translations loading
            useEffect(() => {
                window.forceUpdate = () => setRefreshKey(prev => prev + 1);
                return () => { window.forceUpdate = null; };
            }, []);

            // Load state from URL hash on mount
            useEffect(() => {
                const hash = window.location.hash.substring(1);
                if (hash) {
                    const state = decodeState(hash);
                    if (state) {
                        // Restore language first, as it affects other state
                        if (state.language) {
                            setLanguage(state.language);
                        }
                        setStudentName(state.name || '');
                        setCurrentLessonIndex(state.lessonIndex || 0);
                        setCode(state.code || '');
                        // Restore completed lessons from array to Set
                        if (state.completedLessons && Array.isArray(state.completedLessons)) {
                            setCompletedLessons(new Set(state.completedLessons));
                        }
                        setHasStarted(true);
                    }
                }
            }, []);

            // Update URL hash when state changes - saves code continuously as user types
            useEffect(() => {
                if (hasStarted && studentName) {
                    const state = {
                        name: studentName,
                        lessonIndex: currentLessonIndex,
                        code: code, // This saves the code every time it changes
                        language: language, // Save language preference
                        // Convert Set to array for JSON serialization
                        completedLessons: Array.from(completedLessons)
                    };
                    const hash = encodeState(state);
                    // Use replaceState to avoid adding to browser history on every keystroke
                    window.history.replaceState(null, '', '#' + hash);
                }
            }, [studentName, currentLessonIndex, code, completedLessons, hasStarted, language]);

            // Update preview when code changes with basic styling
            useEffect(() => {
                if (previewFrameRef.current && code) {
                    const iframe = previewFrameRef.current;
                    const doc = iframe.contentDocument;
                    
                    // Inject basic styling if not already present
                    let styledCode = code;
                    if (!code.includes('<style>') && !code.includes('</style>')) {
                        const basicStyles = `
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3, h4, h5, h6 {
            margin: 20px 0 10px 0;
            color: #2c3e50;
        }
        p {
            margin: 10px 0;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        a:focus {
            outline: 3px solid #3498db;
            outline-offset: 2px;
        }
        img {
            max-width: 100%;
            height: auto;
        }
        ul, ol {
            margin: 10px 0 10px 20px;
        }
        li {
            margin: 5px 0;
        }
    </style>
`;
                        // Insert styles before </head> or at the beginning if no head
                        if (code.includes('</head>')) {
                            styledCode = code.replace('</head>', basicStyles + '</head>');
                        } else if (code.includes('<head>')) {
                            styledCode = code.replace('<head>', '<head>' + basicStyles);
                        } else if (code.includes('<html>')) {
                            styledCode = code.replace('<html>', '<html><head>' + basicStyles + '</head>');
                        } else {
                            styledCode = '<!DOCTYPE html><html><head>' + basicStyles + '</head><body>' + code + '</body></html>';
                        }
                    }
                    
                    doc.open();
                    doc.write(styledCode);
                    doc.close();
                }
            }, [code]);

            const handleNameSubmit = (e) => {
                e.preventDefault();
                const nameInput = e.target.querySelector('input');
                const name = nameInput.value.trim();
                if (name) {
                    setStudentName(name);
                    setHasStarted(true);
                    const firstLesson = getTranslatedLesson(lessons[0], language);
                    setCode(firstLesson.codeTemplate || '');
                }
            };

            const handleVerify = () => {
                const currentLessonRaw = lessons[currentLessonIndex];
                const currentLesson = getTranslatedLesson(currentLessonRaw, language);
                if (currentLessonRaw.validator(code)) {
                    setFeedback({ type: 'success', message: t('ui.successMessage') });
                    // Mark lesson as completed
                    setCompletedLessons(prev => new Set([...prev, currentLessonIndex]));
                } else {
                    const expectedElements = currentLesson.expectedElements || currentLessonRaw.expectedElements;
                    const elementsText = Array.isArray(expectedElements) ? expectedElements.join(', ') : expectedElements;
                    setFeedback({ 
                        type: 'error', 
                        message: t('ui.errorMessage', { elements: elementsText })
                    });
                }
            };

            const handleNext = () => {
                if (currentLessonIndex < lessons.length - 1) {
                    setCurrentLessonIndex(currentLessonIndex + 1);
                    const nextLessonRaw = lessons[currentLessonIndex + 1];
                    const nextLesson = getTranslatedLesson(nextLessonRaw, language);
                    setCode(nextLesson.codeTemplate || '');
                    setFeedback(null);
                    setHintExpanded(false); // Reset hint when moving to next lesson
                }
            };

            const handleBack = () => {
                if (currentLessonIndex > 0) {
                    // Current code is already saved via useEffect
                    const prevLessonIndex = currentLessonIndex - 1;
                    setCurrentLessonIndex(prevLessonIndex);
                    const prevLessonRaw = lessons[prevLessonIndex];
                    const prevLesson = getTranslatedLesson(prevLessonRaw, language);
                    // Load template for previous lesson (code will be saved as user types)
                    setCode(prevLesson.codeTemplate || '');
                    setFeedback(null);
                    setHintExpanded(false); // Reset hint when moving to previous lesson
                }
            };

            const handleSkip = () => {
                if (currentLessonIndex < lessons.length - 1) {
                    // Save current code before skipping
                    setCurrentLessonIndex(currentLessonIndex + 1);
                    const nextLessonRaw = lessons[currentLessonIndex + 1];
                    const nextLesson = getTranslatedLesson(nextLessonRaw, language);
                    setCode(nextLesson.codeTemplate || '');
                    setFeedback(null);
                    setHintExpanded(false); // Reset hint when skipping
                }
            };

            const handleTryAgain = () => {
                setFeedback(null);
            };

            // Jump to first lesson of a section
            const jumpToSection = (category) => {
                const firstLessonIndex = lessons.findIndex(l => l.category === category);
                if (firstLessonIndex !== -1) {
                    setCurrentLessonIndex(firstLessonIndex);
                    const targetLessonRaw = lessons[firstLessonIndex];
                    const targetLesson = getTranslatedLesson(targetLessonRaw, language);
                    setCode(targetLesson.codeTemplate || '');
                    setFeedback(null);
                    setHintExpanded(false);
                }
            };

            // Helper function to calculate indentation based on tag structure
            const calculateIndentation = (text, lineIndex) => {
                const lines = text.split('\n');
                let indentLevel = 0;
                
                // Count opening and closing tags up to this line
                for (let i = 0; i <= lineIndex && i < lines.length; i++) {
                    const line = lines[i];
                    // Count opening tags (but not self-closing or comments)
                    const openingTags = (line.match(/<[^/!?][^>]*>/g) || []).filter(tag => 
                        !tag.endsWith('/>') && 
                        !tag.startsWith('<!--') &&
                        !tag.startsWith('<!')
                    ).length;
                    // Count closing tags
                    const closingTags = (line.match(/<\/[^>]+>/g) || []).length;
                    // Count self-closing tags (reduce indent since they don't need closing)
                    const selfClosingTags = (line.match(/<[^>]+\/>/g) || []).length;
                    
                    indentLevel += openingTags - closingTags - selfClosingTags;
                }
                
                return '    '.repeat(Math.max(0, indentLevel));
            };
            
            // Auto-indentation handler
            const handleKeyDown = (e) => {
                const textarea = e.target;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const value = textarea.value;

                // Handle Tab key - indent/unindent
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const lines = value.split('\n');
                    const lineIndex = value.substring(0, start).split('\n').length - 1;
                    const currentLine = lines[lineIndex] || '';
                    
                    if (e.shiftKey) {
                        // Shift+Tab: unindent
                        if (currentLine.startsWith('    ')) {
                            lines[lineIndex] = currentLine.substring(4);
                            const newValue = lines.join('\n');
                            setCode(newValue);
                            setTimeout(() => {
                                const newStart = Math.max(0, start - 4);
                                const newEnd = Math.max(0, end - 4);
                                textarea.setSelectionRange(newStart, newEnd);
                            }, 0);
                        }
                    } else {
                        // Tab: indent
                        lines[lineIndex] = '    ' + currentLine;
                        const newValue = lines.join('\n');
                        setCode(newValue);
                        setTimeout(() => {
                            const newStart = start + 4;
                            const newEnd = end + 4;
                            textarea.setSelectionRange(newStart, newEnd);
                        }, 0);
                    }
                    return;
                }
                
                // Handle Enter key - maintain indentation based on tag structure
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const lines = value.split('\n');
                    const lineIndex = value.substring(0, start).split('\n').length - 1;
                    const currentLine = lines[lineIndex] || '';
                    
                    // Get text before cursor
                    const beforeCursor = value.substring(0, start);
                    const textBeforeOnLine = beforeCursor.split('\n').pop() || '';
                    
                    // Check if current line ends with opening tag (not self-closing, not closing, not comment)
                    const trimmedBefore = textBeforeOnLine.trim();
                    const endsWithOpeningTag = trimmedBefore.endsWith('>') && 
                                               !trimmedBefore.endsWith('/>') && 
                                               !trimmedBefore.endsWith('-->') &&
                                               trimmedBefore.startsWith('<') &&
                                               !trimmedBefore.startsWith('</');
                    
                    // Check if we're right after a closing tag
                    const endsWithClosingTag = trimmedBefore.endsWith('>') && 
                                               trimmedBefore.startsWith('</');
                    
                    // Get current line indentation
                    const match = currentLine.match(/^(\s*)/);
                    const currentIndent = match ? match[1] : '';
                    
                    // Calculate proper indentation
                    let indent = currentIndent;
                    if (endsWithOpeningTag) {
                        // After opening tag - indent one level more for content
                        indent = currentIndent + '    ';
                    } else if (endsWithClosingTag) {
                        // After closing tag - check if we should unindent
                        // Count opening tags before this line to determine proper indent
                        let tagLevel = 0;
                        for (let i = 0; i < lineIndex; i++) {
                            const line = lines[i];
                            const opening = (line.match(/<[^/!?][^>]*>/g) || []).filter(t => 
                                !t.endsWith('/>') && !t.startsWith('<!--')
                            ).length;
                            const closing = (line.match(/<\/[^>]+>/g) || []).length;
                            const selfClosing = (line.match(/<[^>]+\/>/g) || []).length;
                            tagLevel += opening - closing - selfClosing;
                        }
                        // Unindent one level for the closing tag
                        indent = '    '.repeat(Math.max(0, tagLevel));
                    } else {
                        // Regular line - maintain current indentation
                        indent = currentIndent;
                    }
                    
                    const before = value.substring(0, start);
                    const after = value.substring(end);
                    const newValue = before + '\n' + indent + after;
                    setCode(newValue);
                    setTimeout(() => {
                        const newPos = start + 1 + indent.length;
                        textarea.setSelectionRange(newPos, newPos);
                    }, 0);
                    return;
                }
                
                // Handle typing '>' - check if we need to auto-adjust indentation
                if (e.key === '>') {
                    const before = value.substring(0, start);
                    const lines = value.split('\n');
                    const lineIndex = value.substring(0, start).split('\n').length - 1;
                    const currentLine = lines[lineIndex] || '';
                    const textBeforeOnLine = before.split('\n').pop() || '';
                    
                    // Check if we're typing a closing tag like </div>
                    if (textBeforeOnLine.trim().startsWith('</')) {
                        // Calculate proper indentation for closing tag
                        let tagLevel = 0;
                        for (let i = 0; i < lineIndex; i++) {
                            const line = lines[i];
                            const opening = (line.match(/<[^/!?][^>]*>/g) || []).filter(t => 
                                !t.endsWith('/>') && !t.startsWith('<!--')
                            ).length;
                            const closing = (line.match(/<\/[^>]+>/g) || []).length;
                            const selfClosing = (line.match(/<[^>]+\/>/g) || []).length;
                            tagLevel += opening - closing - selfClosing;
                        }
                        
                        // Auto-adjust indentation if needed
                        const properIndent = '    '.repeat(Math.max(0, tagLevel));
                        const currentIndent = currentLine.match(/^(\s*)/)?.[1] || '';
                        
                        if (currentIndent !== properIndent) {
                            e.preventDefault();
                            const indentDiff = properIndent.length - currentIndent.length;
                            const newLine = properIndent + textBeforeOnLine.trim() + '>';
                            lines[lineIndex] = newLine;
                            const newValue = lines.join('\n');
                            setCode(newValue);
                            setTimeout(() => {
                                const newPos = start + indentDiff;
                                textarea.setSelectionRange(newPos, newPos);
                            }, 0);
                            return;
                        }
                    }
                }
            };
            
            // Auto-format on paste or when typing closing tags
            const handleCodeChange = (newValue) => {
                setCode(newValue);
                
                // Optional: Auto-format indentation when user types closing tags
                // This could be enhanced to reformat entire code, but might be too aggressive
            };

            // Calculate progress for each section
            const getSectionProgress = (category) => {
                const sectionLessons = lessons.filter(l => l.category === category);
                let completed = 0;
                sectionLessons.forEach(lesson => {
                    const lessonIdx = lessons.findIndex(l => l.id === lesson.id);
                    if (completedLessons.has(lessonIdx)) {
                        completed++;
                    }
                });
                return { completed, total: sectionLessons.length };
            };

            const htmlFundamentalsProgress = getSectionProgress('HTML Fundamentals');
            const htmlProgress = getSectionProgress('HTML');
            const cssProgress = getSectionProgress('CSS');
            const accessibilityProgress = getSectionProgress('Accessibility');

            const isSectionComplete = (progress) => progress.completed === progress.total && progress.total > 0;

            const currentLessonRaw = lessons[currentLessonIndex];
            const currentLesson = getTranslatedLesson(currentLessonRaw, language);
            const isLastLesson = currentLessonIndex === lessons.length - 1;
            const isVerified = feedback?.type === 'success';
            const allLessonsComplete = completedLessons.size === lessons.length;

            // Show certificate when all lessons are complete
            if (allLessonsComplete && hasStarted && studentName) {
                const completionDate = new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                
                return (
                    <div className="certificate" role="main" aria-label={t('ui.certificateTitle')}>
                        <div className="certificate-content">
                            <h1>{t('ui.certificateTitle')}</h1>
                            <h2>{t('ui.certificateSubtitle')}</h2>
                            <p className="description">
                                {t('ui.certificateDescription')}
                            </p>
                            <div className="student-name" aria-label={t('ui.studentNameAria', { name: studentName })}>
                                {studentName}
                            </div>
                            <p className="description">
                                <TextWithTooltips text={t('ui.certificateCompleted')} />
                            </p>
                            <p className="description" style={{ marginTop: '40px' }}>
                                {t('ui.certificateCovered')}
                            </p>
                            <ul style={{ textAlign: 'left', display: 'inline-block', marginTop: '20px', fontSize: '16px', lineHeight: '2' }}>
                                <li><TextWithTooltips text="HTML" /> Fundamentals and Document Structure</li>
                                <li><TextWithTooltips text="CSS" /> Styling and Layout</li>
                                <li><TextWithTooltips text="Accessible" /> Web Design Principles</li>
                                <li><TextWithTooltips text="Semantic HTML" /> and <TextWithTooltips text="Keyboard Navigation" /></li>
                            </ul>
                            <p className="date">
                                {t('ui.completedOn')} {completionDate}
                            </p>
                            <div style={{ marginTop: '40px', fontSize: '48px' }} role="img" aria-label={t('ui.congratulations')}>🎉</div>
                        </div>
                    </div>
                );
            }

            if (!hasStarted || !studentName) {
                return (
                    <div className="app-container">
                        <div className="lesson-panel">
                            <div className="header">
                                <div className="header-content">
                                    <h1>{t('ui.title')}</h1>
                                    <p>{t('ui.subtitle')}</p>
                                </div>
                                <div className="language-selector">
                                    <label htmlFor="language-select" className="sr-only">{t('ui.selectLanguage')}</label>
                                    <select 
                                        id="language-select"
                                        value={language} 
                                        onChange={(e) => setLanguage(e.target.value)}
                                        aria-label={t('ui.selectLanguage')}
                                    >
                                        <option value="en">English</option>
                                        <option value="fr">Français</option>
                                    </select>
                                </div>
                            </div>
                            <div className="lesson-content">
                                <div className="welcome-screen">
                                    <h2>{t('ui.welcome')}</h2>
                                    <p>
                                        <TextWithTooltips text={t('ui.welcomeDescription')} />
                                    </p>
                                    <p style={{ fontSize: '14px', color: '#888', fontStyle: 'italic', marginTop: '30px', paddingTop: '20px', borderTop: '1px solid #e0e0e0' }}>
                                        {t('ui.tutorialCredit')}
                                    </p>
                                    <form onSubmit={handleNameSubmit} className="name-input">
                                        <label htmlFor="student-name-input" className="sr-only">{t('ui.enterName')}</label>
                                        <input 
                                            id="student-name-input"
                                            type="text" 
                                            placeholder={t('ui.enterName')} 
                                            value={studentName} 
                                            onChange={(e) => setStudentName(e.target.value)}
                                            required
                                            autoFocus
                                            aria-label={t('ui.enterName')}
                                        />
                                        <button type="submit" className="btn btn-primary" aria-label={t('ui.startLearning')}>{t('ui.startLearning')}</button>
                                    </form>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="app-container">
                    <div className="lesson-panel">
                        <div className="header">
                            <div className="header-content">
                                <h1>{t('ui.title')}</h1>
                                <p>{t('ui.welcomeUser', { name: studentName, current: currentLessonIndex + 1, total: lessons.length })}</p>
                            </div>
                            <div className="language-selector">
                                <label htmlFor="language-select-main" className="sr-only">{t('ui.selectLanguage')}</label>
                                <select 
                                    id="language-select-main"
                                    value={language} 
                                    onChange={(e) => setLanguage(e.target.value)}
                                    aria-label={t('ui.selectLanguage')}
                                >
                                    <option value="en">English</option>
                                    <option value="fr">Français</option>
                                </select>
                            </div>
                        </div>
                        <div className="progress-section">
                            <div className="progress-title">{t('ui.courseProgress')}</div>
                            <div className="progress-circles">
                                <div className="progress-circle-container">
                                    <div 
                                        className={`progress-circle ${isSectionComplete(htmlFundamentalsProgress) ? 'completed' : htmlFundamentalsProgress.completed > 0 ? 'in-progress' : ''}`}
                                        onClick={() => jumpToSection('HTML Fundamentals')}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter' || e.key === ' ') {
                                                e.preventDefault();
                                                jumpToSection('HTML Fundamentals');
                                            }
                                        }}
                                        tabIndex="0"
                                        role="button"
                                        aria-label={t('ui.jumpToSection', { section: t('categories.htmlFundamentals'), completed: htmlFundamentalsProgress.completed, total: htmlFundamentalsProgress.total })}
                                    >
                                        {htmlFundamentalsProgress.completed}/{htmlFundamentalsProgress.total}
                                        {isSectionComplete(htmlFundamentalsProgress) && (
                                            <span className="progress-star" role="img" aria-label={t('ui.completed')}>⭐</span>
                                        )}
                                    </div>
                                    <div className="progress-label">{t('categories.htmlFundamentals')}</div>
                                </div>
                                <div className="progress-circle-container">
                                    <div 
                                        className={`progress-circle ${isSectionComplete(htmlProgress) ? 'completed' : htmlProgress.completed > 0 ? 'in-progress' : ''}`}
                                        onClick={() => jumpToSection('HTML')}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter' || e.key === ' ') {
                                                e.preventDefault();
                                                jumpToSection('HTML');
                                            }
                                        }}
                                        tabIndex="0"
                                        role="button"
                                        aria-label={t('ui.jumpToSection', { section: t('categories.html'), completed: htmlProgress.completed, total: htmlProgress.total })}
                                    >
                                        {htmlProgress.completed}/{htmlProgress.total}
                                        {isSectionComplete(htmlProgress) && (
                                            <span className="progress-star" role="img" aria-label={t('ui.completed')}>⭐</span>
                                        )}
                                    </div>
                                    <div className="progress-label">{t('categories.html')}</div>
                                </div>
                                <div className="progress-circle-container">
                                    <div 
                                        className={`progress-circle ${isSectionComplete(cssProgress) ? 'completed' : cssProgress.completed > 0 ? 'in-progress' : ''}`}
                                        onClick={() => jumpToSection('CSS')}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter' || e.key === ' ') {
                                                e.preventDefault();
                                                jumpToSection('CSS');
                                            }
                                        }}
                                        tabIndex="0"
                                        role="button"
                                        aria-label={t('ui.jumpToSection', { section: t('categories.css'), completed: cssProgress.completed, total: cssProgress.total })}
                                    >
                                        {cssProgress.completed}/{cssProgress.total}
                                        {isSectionComplete(cssProgress) && (
                                            <span className="progress-star" role="img" aria-label={t('ui.completed')}>⭐</span>
                                        )}
                                    </div>
                                    <div className="progress-label">{t('categories.css')}</div>
                                </div>
                                <div className="progress-circle-container">
                                    <div 
                                        className={`progress-circle ${isSectionComplete(accessibilityProgress) ? 'completed' : accessibilityProgress.completed > 0 ? 'in-progress' : ''}`}
                                        onClick={() => jumpToSection('Accessibility')}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter' || e.key === ' ') {
                                                e.preventDefault();
                                                jumpToSection('Accessibility');
                                            }
                                        }}
                                        tabIndex="0"
                                        role="button"
                                        aria-label={t('ui.jumpToSection', { section: t('categories.accessibility'), completed: accessibilityProgress.completed, total: accessibilityProgress.total })}
                                    >
                                        {accessibilityProgress.completed}/{accessibilityProgress.total}
                                        {isSectionComplete(accessibilityProgress) && (
                                            <span className="progress-star" role="img" aria-label={t('ui.completed')}>⭐</span>
                                        )}
                                    </div>
                                    <div className="progress-label">{t('categories.accessibility')}</div>
                                </div>
                            </div>
                        </div>
                        <div className="progress-indicator">
                            <span>{currentLesson.category}: {currentLesson.title}</span>
                        </div>
                        <div className="lesson-content">
                            <div className="lesson-section">
                                <h2 className="lesson-title">{currentLesson.title}</h2>
                                <div className="lesson-description">
                                    <p><strong>{t('ui.whatWeLearning')}</strong> <TextWithTooltips text={currentLesson.description} /></p>
                                    <p style={{ marginTop: '15px' }}>
                                        <strong>{t('ui.whyImportant')}</strong> <TextWithTooltips text={currentLesson.whyImportant} />
                                    </p>
                                </div>

                                {currentLesson.whatToDo && (
                                    <div className="hint-section">
                                        <button
                                            className="hint-button"
                                            onClick={() => setHintExpanded(!hintExpanded)}
                                            aria-expanded={hintExpanded}
                                            aria-controls="hint-content"
                                            aria-label={hintExpanded ? t('ui.hideHint') : t('ui.showHint')}
                                        >
                                            <span>{t('ui.needHint')}</span>
                                            <span className="hint-icon" aria-hidden="true">▼</span>
                                        </button>
                                        <div
                                            id="hint-content"
                                            className="hint-content"
                                            aria-hidden={!hintExpanded}
                                            role="region"
                                            aria-label={t('ui.hintRegion')}
                                        >
                                            <h3>{t('ui.whatToDo')}</h3>
                                            <ol>
                                                {currentLesson.whatToDo.map((step, index) => (
                                                    <li key={index}><TextWithTooltips text={step} /></li>
                                                ))}
                                            </ol>
                                        </div>
                                    </div>
                                )}

                                <div className="code-input">
                                    <label htmlFor="code-editor">{t('ui.typeCodeHere')}</label>
                                    <div className="code-editor-container">
                                        <div className="code-editor-header">
                                            <div className="code-editor-dot red" aria-hidden="true"></div>
                                            <div className="code-editor-dot yellow" aria-hidden="true"></div>
                                            <div className="code-editor-dot green" aria-hidden="true"></div>
                                            <span className="code-editor-title">code.html</span>
                                        </div>
                                        <textarea
                                            id="code-editor"
                                            value={code}
                                            onChange={(e) => handleCodeChange(e.target.value)}
                                            onKeyDown={handleKeyDown}
                                            placeholder="<!-- Start typing your HTML/CSS code here... -->"
                                            aria-label="Code editor for typing HTML and CSS"
                                            aria-describedby="code-editor-description"
                                        />
                                    </div>
                                    <div id="code-editor-description" className="sr-only">
                                        {t('ui.codeEditorDescription')}
                                    </div>
                                </div>

                                <div className="button-group">
                                    {currentLessonIndex > 0 && (
                                        <button onClick={handleBack} className="btn btn-secondary" aria-label={t('ui.back')}>
                                            {t('ui.back')}
                                        </button>
                                    )}
                                    <button onClick={handleVerify} className="btn btn-primary" aria-label={t('ui.verifyCode')}>
                                        {t('ui.verifyCode')}
                                    </button>
                                    {!isLastLesson && (
                                        <button onClick={handleSkip} className="btn btn-secondary" aria-label={t('ui.skip')}>
                                            {t('ui.skip')}
                                        </button>
                                    )}
                                    {feedback && (
                                        <>
                                            {feedback.type === 'error' && (
                                                <button onClick={handleTryAgain} className="btn btn-secondary" aria-label={t('ui.tryAgain')}>
                                                    {t('ui.tryAgain')}
                                                </button>
                                            )}
                                            {isVerified && !isLastLesson && (
                                                <button onClick={handleNext} className="btn btn-success" aria-label={t('ui.nextLesson')}>
                                                    {t('ui.nextLesson')}
                                                </button>
                                            )}
                                        </>
                                    )}
                                </div>

                                {feedback && (
                                    <div className={`feedback ${feedback.type}`}>
                                        {feedback.message}
                                    </div>
                                )}

                                {currentLesson.w3schoolsLinks && currentLesson.w3schoolsLinks.length > 0 && (
                                    <div className="w3schools-links">
                                        <h3>{t('ui.learnMore')}</h3>
                                        <ul>
                                            {currentLesson.w3schoolsLinks.map((link, index) => (
                                                <li key={index}>
                                                    <a 
                                                        href={link.url} 
                                                        target="_blank" 
                                                        rel="noopener noreferrer"
                                                        aria-label={`${link.text} - opens in new tab`}
                                                    >
                                                        {link.text}
                                                    </a>
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                )}

                                <div className="url-share">
                                    <p><strong>{t('ui.tip')}</strong> {t('ui.copyUrl')}</p>
                                    <input 
                                        type="text" 
                                        readOnly 
                                        value={window.location.href}
                                        onClick={(e) => e.target.select()}
                                    />
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="preview-panel">
                        <div className="preview-header">
                            {t('ui.preview')}
                        </div>
                        <iframe
                            ref={previewFrameRef}
                            className="preview-frame"
                            title={t('ui.previewAria')}
                            aria-label={t('ui.previewAria')}
                            sandbox="allow-same-origin allow-scripts"
                        />
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
